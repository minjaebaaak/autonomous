# Autonomous Mode v4.2 - 범용 프레임워크

> **`/autonomous [작업]` 하나로 모든 최적화가 자동 적용됩니다.**
>
> v4.2: Phase 0 복잡도 기반 분기 (Simple → grep만 / Complex → nlm 강제).

---

## 🛑 Phase 0: MANDATORY PRE-CHECK

> **🔴 이 단계를 건너뛰면 규칙 위반. 모든 작업은 여기서 시작.**
>
> **핵심**: 규칙의 존재 ≠ 규칙 준수. 강제 메커니즘이 필요하다.

### 🔴 실행 순서 (반드시 순서대로 - 건너뛰기 금지)

**Step 0: 작업 복잡도 판정** (필수 - 생략 금지)

작업을 아래 기준으로 분류한다:

| 분류 | 기준 | Phase 0 경로 |
|------|------|-------------|
| **Simple** | 텍스트 교체, CSS/스타일링, 오타 수정, 단일 파일 내 수정 | → Step 1-S (간소화) |
| **Complex** | 코드 로직 변경, 버그 수정, 새 기능, 아키텍처 관련, 다중 파일 수정 | → Step 1-C (nlm 강제) |

🔴 필수 출력 (건너뛰기 금지):
```
📋 복잡도 판정: [Simple / Complex]
  - 사유: [1줄]
```

**Step 1-S: Simple 작업 — grep으로 영향 범위 확인**

- Grep으로 변경 대상 검색 (전체 codebase)
- nlm query / 기술문서 Read **불필요** (토큰 절약)
- 바로 Step 2로 진행

**Step 1-C: Complex 작업 — 기술문서 참조 (필수)**

CLAUDE.md "Phase 확장 설정"에서 **Phase 0 NotebookLM** 항목을 찾는다:

**A) NotebookLM 설정이 있으면 (노트북 ID가 명시됨):**
```bash
# 🔴 반드시 아래 Bash 명령을 실행할 것 (Read 도구로 기술문서 직접 읽기 금지)
export PATH="$HOME/Library/Python/3.14/bin:$HOME/.local/bin:$PATH"
nlm notebook query "<노트북ID>" "<작업 관련 질의>"

# 예시:
# nlm notebook query "af7bfaf0-..." "SERP 수집 관련 파일과 함수는?"
# nlm notebook query "af7bfaf0-..." "프론트엔드 대시보드 구조는?"
```
- 질의 결과에서 관련 파일/함수 목록을 추출한다
- 필요 시 grep으로 교차 검증한다
- **🔴 nlm 성공 시 Read 도구로 기술문서 전체를 읽지 않는다** (토큰 낭비)

**B) NotebookLM 설정이 없으면:**
- 기술문서를 Read 도구로 직접 읽는다

**C) nlm 실패 시 (command not found, 인증 만료 등):**
- fallback: 기술문서를 Read 도구로 직접 읽는다
- 인증 만료: `nlm login` 실행 후 재시도 (1회)

**Step 2: 관련 섹션 식별 및 출력** (필수)
```
작업: [사용자 요청 요약]
관련 섹션: [CLAUDE.md "Phase 0 확장: 섹션 매핑" 참조, 없으면 자체 판단]
관련 파일: [기술문서에서 추출한 파일 목록]
```

**Step 3: Phase 0 완료 선언** (필수)
```
✅ Phase 0 완료 - 기술문서 확인됨
```

### 자가 점검 질문 (매 작업 시작 시)

```
"기술문서 먼저 확인했나?"
  → 아니면 즉시 Phase 0 실행

"Phase 0 완료 메시지 출력했나?"
  → 아니면 아직 시작 안 한 것

"관련 파일 목록 추출했나?"
  → 아니면 Phase 0 미완료
```

### Phase 0 미완료 시 조치

1. **즉시 중단**
2. **Phase 0으로 복귀**
3. **기술문서 읽기부터 다시 시작**

---

## 📊 문서 동기화 시스템

> **프로젝트 문서는 Single Source of Truth**

### 🔴 핵심 개발 원칙
1. **문서 기반 개발**: 작업 전 프로젝트 기술문서에서 관련 파일/함수 확인
2. **문서 동기화**: 코드 변경 시 관련 문서도 **반드시** 업데이트
3. **커밋 전 확인**: 문서 업데이트 없이 코드 커밋 **금지**
4. **코드와 문서는 한 커밋에**: 코드만 커밋하고 문서는 나중에 = **규칙 위반**

---

## 자동 활성화 기능

| 기능 | 설명 | 상태 |
|------|------|------|
| **🛑 Phase 0 강제** | 작업 전 기술문서 확인 필수 (건너뛰기 불가) | ✅ 자동 (v2.8) |
| **🔍 에이전트 결과 검증** | 서브에이전트 보고값 원본 대조 필수 | ✅ 자동 (v2.9) |
| **🔄 양방향 동기화** | 프로젝트 교훈 → 범용화 | ✅ 자동 (v3.0) |
| **👥 Agent Teams 필수 판단** | 매 작업마다 팀원 필요 여부 판단 + 출력 의무 | ✅ 강제 (v3.3) |
| **🔢 Agent 결과 교차 검증** | Agent 보고 수량을 독립 Grep으로 교차 검증 + 결과 출력 | ✅ 강제 (v3.3) |
| **📚 기술문서 참조** | 작업 전 프로젝트 기술문서에서 파일/함수 확인 | ✅ 자동 |
| **📝 문서 업데이트** | 코드 변경 후 관련 문서 자동 업데이트 | ✅ 자동 |
| **🔄 autonomous 자동 커밋** | autonomous.md 개선 시 자동 git 반영 | ✅ 자동 (v2.5) |
| **📋 커밋 전 문서 확인** | 문서 업데이트 강제 확인 | ✅ 자동 (v2.6) |
| **AEGIS Protocol** | 7-Layer 검증 프레임워크 | ✅ 자동 |
| **ultrathink** | 심층 분석 모드 | ✅ 자동 |
| **Sequential Thinking** | 복잡한 문제 시 단계별 사고 | ✅ 필요 시 |
| **TodoWrite** | 진행 추적 | ✅ 자동 |
| **피드백 루프** | 완료 후 자동 검증 (3회) | ✅ 자동 |
| **🔄 랄프 루프** | 목표 달성까지 무한 반복 (최대 10회) | ✅ 자동 |
| **🔄 작업 완료 자동 커밋** | 작업 완료 시 자동 git commit & push | ✅ 강제 (v3.6) |
| **📋 복잡도 판정** | Phase 0 Step 0에서 Simple/Complex 분류 출력 | ✅ 강제 (v4.2) |
| **📓 NotebookLM 질의** | Phase 0 Complex 작업에서 nlm query 강제 (설정 있을 때) | ✅ 강제 (v4.2) |

---

## 실행 지침

주어진 작업: $ARGUMENTS

### Phase 1: 초기화
```bash
mkdir -p ~/.claude/state && touch ~/.claude/state/AUTONOMOUS_MODE
```

### Phase 2: 📝 문서 업데이트 의무

> **🔴 코드 변경 후 관련 문서 섹션 자동 업데이트 - 사용자 요청 불필요**

**CLAUDE.md에 "Phase 2 확장: 파일→문서 매핑"이 있으면 해당 매핑에 따라 업데이트.**
**없으면: 수정한 파일과 관련된 프로젝트 문서를 찾아서 업데이트.**

**필수 업데이트 워크플로우**:
```
1. 코드 수정 완료
2. 빌드 검증 통과
3. 🔴 관련 문서 업데이트 (자동 - 사용자 요청 불필요)
4. 커밋 & 푸시
5. 프로덕션 배포
```

**절대 금지**:
```
❌ 코드 수정 후 문서 업데이트 없이 커밋
❌ "문서 업데이트 할까요?" 질문
❌ 사용자가 "문서 업데이트해" 말할 때까지 대기
```

### Phase 3: 🔄 autonomous.md 자동 커밋

> **🔴 autonomous.md 개선 시 자동으로 git 커밋 & 푸시 - 사용자 요청 불필요**

**필수 워크플로우**:
```
1. ~/.claude/commands/autonomous.md 수정 (전역 = 범용)
2. 버전 번호 증가 (예: v3.0 → v3.1)
3. autonomous 레포에 복사 + README.md 업데이트
4. 🔴 자동 커밋 & 푸시
```

**🔴 전역 = 유일한 SSOT (v3.6 교훈)**:
```
- 수정: 반드시 전역(`~/.claude/commands/autonomous.md`)에서만
- 레포: 전역 복사본일 뿐. 직접 수정 절대 금지
- 방향: 전역 → 레포 단방향만 허용
```

**절대 금지**:
```
❌ autonomous.md 수정 후 커밋하지 않음
❌ README.md 업데이트 없이 autonomous.md만 커밋
❌ "커밋할까요?" 질문
❌ autonomous 레포에서 직접 autonomous.md 수정 (전역 우회)
❌ 레포에서 버전 올리고 전역에 미반영
```

---

### Phase 3.5: 🔄 양방향 동기화 규칙 (v3.0 신규)

> **autonomous = 지혜의 집약체. 프로젝트에서 배운 교훈은 범용으로 승격.**

**구조**:
```
autonomous 레포/
├── .claude/commands/autonomous.md     # 범용 (지혜의 집약체)
├── projects/[프로젝트]/
│   ├── CLAUDE-ext.md                  # 프로젝트 Phase 확장 백업
│   └── autonomous-history.md          # 프로젝트 교훈 아카이브
```

**규칙**:
```
1. 범용 autonomous.md 수정 시:
   - ~/.claude/commands/autonomous.md 수정 (전역 = 실제 사용 파일)
   - autonomous 레포에 복사 + README.md 업데이트
   - autonomous 레포에 커밋 & 푸시
   → 모든 프로젝트에 즉시 반영 (전역이므로)

2. 프로젝트 교훈 발생 시:
   - 해당 프로젝트 CLAUDE.md의 Phase 확장에 기록
   - 범용화 가능한 교훈이면 → 프로젝트 특화 세부사항을 추상화
     → 범용 autonomous.md에 추상화 버전 추가
   - autonomous 레포 projects/[프로젝트]/autonomous-history.md에 원본 기록
   - autonomous 레포 projects/[프로젝트]/CLAUDE-ext.md에 Phase 확장 백업
   - autonomous 레포에 커밋 & 푸시

3. CLAUDE.md Phase 확장 수정 시:
   - autonomous 레포 projects/[프로젝트]/CLAUDE-ext.md에 동기화
   - autonomous 레포에 커밋 & 푸시
```

**범용화 판단 기준**:
- "이 교훈은 다른 프로젝트에서도 적용 가능한가?"
- 가능하면 → 프로젝트 특화 용어를 제거하고 원칙만 추출
- 예: "source_type='competitor_info' 값 오류" → "에이전트 보고값은 원본과 반드시 대조"

---

### Phase 4: AEGIS 인지 레이어 활성화
- ultrathink 모드로 문제 심층 분석
- 복잡한 문제는 Sequential Thinking MCP 사용
- TodoWrite로 작업 계획 수립

### Phase 4.5: Agent Teams 필수 판단 (🔴 강제)

> **매 작업마다 팀원 필요 여부를 판단하고 결과를 출력해야 한다**
>
> Phase 0처럼 건너뛸 수 없는 강제 단계. 출력 없이 Phase 5 진행 = 규칙 위반.

**🔴 필수 출력** (건너뛰기 금지):
```
📋 팀원 판단:
- 독립 파일 수: [N개]
- SSOT 파일 수정: [있음/없음]
- 순차 의존성: [있음/없음]
- 판정: [단독 진행 / 팀원 N명 구성]
- 사유: [1줄 사유]
```

**판단 기준**:

| 단독 진행 | 팀원 구성 (상한 없음, 범위에 비례) |
|----------|-------------------------------|
| 순차 의존 작업 | 독립 파일 3개+, SSOT 미포함 |
| SSOT 파일 수정 필요 | 다관점 분석 (리뷰) |
| 독립 파일 2개 이하 | 독립 기능 동시 개발 |
| 동일 패턴 반복 | 버그 원인 경쟁 조사 |
| 단순 질문/문서 수정 | 대규모 리팩토링 |

**핵심**: 에이전트 수량 제한 없음 (읽기/쓰기 무관). 작업 범위에 비례하여 자율 결정. 단, SSOT 파일 동시 수정 금지 + 팀원별 담당 파일 겹침 금지 원칙은 유지.

**팀원 구성 시 추가 절차**:
```
1. CLAUDE.md 규칙 #31 체크리스트 실행
2. 팀원별 담당 파일 배정 (겹침 금지)
3. Agent Teams 생성 (delegate mode)
4. 모든 완료 후 리더가 기술표 + 배포
```

**SSOT 파일 목록은 CLAUDE.md 규칙 #8-B 참조.**

**자가 점검**:
```
"팀원 판단을 출력했나?"
  → 아니면 Phase 4.5 미완료
  → Phase 5로 진행 금지
```

### Phase 5: 자율 실행 규칙
- 기술적 판단은 자율 진행 (라이브러리 선택, 코드 구조 등)
- 🔴 단, 사용자 의도가 모호할 때는 반드시 확인 (예: "필요 없다"의 주어 불분명)
- TodoWrite로 모든 진행 상황 추적
- 모든 작업 완료까지 계속 진행
- 오류 발생 시 자체 해결 시도 (최대 3회)
- 배포 전 테스트 포함

### Phase 5.5: 🔍 에이전트 결과 검증 (v3.3 강화)

> **에이전트 결과의 코드 값 + 수량 모두 원본 소스와 대조**

**A. 값 검증** (기존):
1. 에이전트 보고서의 코드 블록에서 핵심 값(변수명, 상수, 함수명) 추출
2. Grep/Read로 원본 파일에서 실제 값 확인
3. 불일치 시 **원본 파일의 값**을 사용

**B. 수량 교차 검증** (v3.3 신규 - 🔴 필수):
1. 에이전트가 "N곳 발견" 보고 시, 독립적 Grep으로 실제 수량 확인
   ```bash
   grep -cn "패턴" 파일.py
   ```
2. 불일치 시 누락분 식별 및 분석
3. **수량 일치 확인 출력 (필수)**:
   ```
   ✅ 수량 교차 검증:
   - 파일: [파일명]
   - Agent 보고: N곳
   - Grep 실제: M곳
   - 불일치: [있음/없음]
   ```

**C. 교차 검증 완료 후에만 플랜 작성 가능** (v3.3 신규):
- Agent 결과 수신 → **반드시** 독립 Grep → 불일치 보고 → 그 후에 플랜 작성
- 이 순서를 건너뛰면 **규칙 위반**

**절대 금지**:
```
❌ 에이전트 보고서의 코드 블록을 검증 없이 그대로 사용
❌ 에이전트가 보고한 변수명/상수값을 확인 없이 코드에 적용
❌ 에이전트 보고 수량을 "전수"로 간주 (독립 Grep 없이)
❌ Agent 결과 수신 → 바로 플랜 작성 (교차 검증 생략)
```

**교훈**: 에이전트가 보고한 값과 수량 모두 실제와 다른 사례가 반복 발생.
Grep으로 확인하면 방지 가능. (v5.41 핫픽스 #5: 14곳 보고 → 실제 18곳)

### Phase 5.6: 🔗 데이터 저장/조회 정합성 원칙 (v3.5 신규)

> **데이터를 저장하는 대상(Sink)과 중복/존재를 확인하기 위해 조회하는 대상(Source)은
> 반드시 일치하거나, Source가 Sink를 포함해야 한다.**

**자가 점검**: "db.add()/insert 대상 모델과 select()/query 대상 모델이 같은가?"

- 적용 시점: 새 모델/테이블 추가, 저장 대상 변경, 중복 체크 로직 작성/수정
- 교훈: 기존 조회 로직을 복사하면서 새 저장 대상을 반영하지 않는 실수가 반복됨

### Phase 5.7: 🔄 반복 실행 로직 멱등성 원칙 (v3.5 신규)

> **스케줄러, cron, 메시지 컨슈머 등 반복 실행되는 로직은
> 반드시 2회 이상 연속 실행하여 부작용(중복 저장, 상태 변이 등)이 없음을 확인한다.**

**자가 점검**: "같은 입력으로 2번 실행하면 결과가 동일한가?"

- 적용 시점: 주기적/이벤트 기반으로 반복 호출되는 모든 서비스
- 교훈: 1회 실행에서는 정상이지만 2회차에서 중복 저장이 발생하는 버그는 프로덕션 운영 중에야 발견됨

### Phase 5.8: 🔗 사용자 여정 일관성 원칙 (v3.7 신규)

> **"계산이 맞다 ≠ 시스템이 맞다."**
> 단일 함수의 기술적 정확성만 확인하고 "버그 아님" 판정하는 것은 단편적 사고.

**필수 검증 순서** (데이터 값 조사 시):
1. 해당 값의 계산 로직 확인 → 맞는가?
2. **🔴 같은 이름의 지표가 다른 곳에도 있는가?** (grep으로 확인)
3. **🔴 해당 화면에서 링크/버튼으로 이동 가능한 페이지의 데이터와 일치하는가?**
4. 모든 표시 지점의 데이터 소스가 동일하거나 일관되는가?

**자가 점검**: "계산이 맞다고 결론 내리려 하고 있나? → 다른 페이지에서도 확인했나?"

- 적용 시점: 사용자가 데이터 값의 정확성을 질문할 때
- 교훈: 단일 API 계산 확인만으로 "정상" 판정 → 연결 페이지에서 불일치 발견

### Phase 5.9: 🔀 횡단 관심사 계층별 sweep 원칙 (v3.8 신규)

> **"한 계층만 수정하고 '전수 완료' 선언하는 것은 착각."**
> 타임존, 인증, 로깅, 에러 핸들링 등 횡단 관심사는 여러 계층에 걸쳐 존재.

**횡단 관심사 수정 시 필수 체크리스트**:
```
□ Layer 1: 모델 — default, server_default, to_dict(), 직렬화
□ Layer 2: 서비스 — 저장 코드, 변환 로직, 캐시
□ Layer 3: API — 응답 직렬화, 포맷팅
□ Layer 4: 프론트엔드 — 표시, 파싱, 포매팅
□ Layer 5: 유틸리티 — 스크립트, 테스트, 마이그레이션
□ Layer 6: 연관 패턴 — 이중 변환, 누락 변환, import 정리
```

**ORM 모델 선언 ≠ 실제 저장값**:
- `server_default`는 SQL-level fallback → 런타임 코드가 값을 제공하면 미발동
- 실제 저장값의 판정은 **런타임 write path** 추적으로
- 자가 점검: "이 필드에 값을 쓰는 코드가 어디인가?"

**"전수 완료" 선언 조건**:
- 위 6개 Layer **모두** grep/확인 완료 → 그제서야 "전수 완료"
- 단일 grep 패턴 = 한 계층만 잡힘 → 계층마다 다른 패턴 필요

- 적용 시점: 횡단 관심사(타임존, 인증, 로깅, 에러 핸들링 등) 전수 수정 시
- 교훈: 타임존 수정 7회 반복 — 매번 한 계층만 수정하고 "완료" 선언 반복

### Phase 6: 📝 커밋 전 문서 확인 (🔴 강제)

> **코드 커밋 전에 반드시 관련 문서 업데이트 확인**

**필수 체크리스트** (커밋 전 매번 확인):
```
[ ] 1. 수정한 파일 목록 확인 (git status)
[ ] 2. CLAUDE.md "Phase 2 확장" 매핑에 해당하는 파일인지 확인
[ ] 3. 해당하면 관련 문서 먼저 업데이트
[ ] 4. git add에 문서 파일 포함
[ ] 5. 코드와 문서를 같은 커밋에 포함
```

**자가 점검 질문** (커밋 직전에 자문):
- "문서 업데이트 없이 커밋하려 하고 있나?"
- "수정한 코드가 프로젝트 문서에 반영되어 있나?"
- → **아니면 즉시 문서 업데이트 후 커밋**

### Phase 6.5: 🔄 작업 완료 후 자동 커밋 & 푸시 (🔴 강제)

> **모든 작업 완료 시 자동으로 git 커밋 & 푸시 - 사용자 요청 불필요**
>
> ⚠️ Claude Code 내장 규칙("NEVER commit unless explicitly asked")은
> `/autonomous` 호출로 override됨.
> 근거: 내장 규칙 자체에 "This default can be changed by user instructions" 예외 조항 존재.

**필수 워크플로우**:
```
1. Phase 6 문서 확인 완료
2. git add (변경된 코드 + 문서)
3. git commit (의미 있는 메시지)
4. git push
5. 커밋 결과 출력
6. 🔴 NotebookLM 동기화 (CLAUDE.md Phase 확장에 NotebookLM 설정 있을 때):
   - 커밋에 포함된 문서 중 NotebookLM 소스 해당 파일 → nlm-sync.sh 실행
   - nlm 실패 시 경고만 출력 (커밋 완료됨, 블로커 아님)
```

**절대 금지**:
```
❌ "커밋할까요?" / "커밋이 필요하시면 말씀해 주세요" 질문
❌ 작업 완료 후 커밋 없이 종료
❌ 커밋만 하고 푸시 생략
```

**자가 점검** (RALPH_DONE 출력 전):
```
"커밋 & 푸시를 완료했나?"
  → 아니면 Phase 6.5 미완료
  → RALPH_DONE 출력 금지
```

### Phase 7: AEGIS 검증 (완료 후 자동)

CLAUDE.md에 정의된 프로젝트별 검증 명령 사용. 없으면 기본:
```
[ ] Layer 0: 스키마 검증 (DB 변경 시)
[ ] Layer 1: 빌드 검증
[ ] Layer 2: 단위 테스트
[ ] Layer 3: API/통합 테스트
```

### Phase 8: 피드백 루프
- 검증 실패 시 자동 수정 시도 (최대 3회)
- 3회 실패 시 Phase 9로 전환

### Phase 9: 🔄 랄프 루프 (Ralph Wiggum Mode)

> **🎢 "놀이터 만들기" 철학**
>
> 랄프가 놀이터를 짓고 미끄럼틀에서 뛰어내리다 다칩니다(실패).
> 그러면 '뛰어내리지 마시오' 표지판(테스트)을 세웁니다.
> 다음번에는 표지판을 보고 안전하게 타고 내려옵니다.
> **실패할 때마다 표지판(검증 규칙)을 세워가며 완벽한 놀이터를 완성!**

**적용 시점**: 테스트/린트 등 **기계적으로 성공/실패 판별 가능한** 작업
- ✅ 추천: 테스트 코드 실행, 린트 검사, Playwright 검증
- ❌ 비추천: A/B/C 선택 등 주관적 판단이 필요한 작업

#### 9.1 상태 파일 생성 (local.md)
```bash
cat > ~/.claude/state/ralph-loop.md << EOF
## Ralph Loop State
- **초기 프롬프트**: $ARGUMENTS
- **현재 반복**: 1 / 10
- **종료 조건**: RALPH_DONE 출력 시
- **시작 시간**: $(date)
EOF
```

#### 9.2 작동 방식 (Stop 훅 연동)
```
Claude will:
1. Work on the task (작업 수행)
2. Try to exit (종료 시도)
3. Stop hook blocks exit (Stop 훅이 종료 차단)
4. Same prompt fed back (초기 프롬프트 재입력)
5. Repeat until RALPH_DONE (RALPH_DONE 출력까지 반복)
```

**핵심 메커니즘:**
```
반복_횟수: 0
local.md 파일 생성 (프롬프트, 상태 기록)

WHILE 반복_횟수 < 10:
    1. 작업 수행
    2. 검증 실행 (AEGIS Layer 0-3)
    3. IF 모든_테스트_통과:
          "RALPH_DONE" 출력 → 루프 종료
       ELSE:
          실패 원인 분석
          표지판 추가 (새로운 검증 규칙/테스트)
          local.md 업데이트 (반복_횟수 += 1)
          초기 프롬프트로 재시작

10회 초과 시:
    - 시도한 접근법 목록 출력
    - 세운 표지판(테스트) 목록
    - 추천 다음 단계 제시
    - 중단
```

#### 9.3 종료 조건
```
✅ 정상 종료: "RALPH_DONE" 출력
   - 모든 테스트 통과
   - 린트 에러 0개
   - 빌드 성공

❌ 강제 종료:
   - 10회 반복 초과
   - touch ~/.claude/state/EMERGENCY_STOP
```

#### 9.4 랄프 루프 vs 피드백 루프
| 구분 | 피드백 루프 | 랄프 루프 |
|------|------------|----------|
| 최대 시도 | 3회 | 10회 |
| 접근법 | 동일 방식 재시도 | **표지판 추가 후** 재시도 |
| 상태 유지 | 메모리 내 | **local.md 파일** |
| 종료 조건 | 성공 또는 3회 실패 | **RALPH_DONE 출력** |
| Stop 훅 | 미사용 | **종료 시도 차단** |

---

## 비상 정지
```bash
touch ~/.claude/state/EMERGENCY_STOP
```

---

## 사용 예시

**Before (기존):**
```
/autonomous ultrathink Sequential Thinking MCP AEGIS protocol 기반으로 배포해줘
```

**After (v3.0):**
```
/autonomous 배포해줘
```
→ 모든 최적화 자동 적용!

---

**즉시 실행을 시작합니다.**
